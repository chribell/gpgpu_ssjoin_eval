#ifndef BITMAP_GPUSSJOIN_BITMAP_HXX
#define BITMAP_GPUSSJOIN_BITMAP_HXX

#pragma once
#include "definitions.h"
#include "structs.hxx"
#include "similarity.hxx"

__forceinline__ __device__ uint32_t hash(uint32_t v)
{
    return v * UINT32_C(2654435761);
}

__forceinline__ __device__ void change_bit(word* ptr, uint32_t bit, unsigned int words)
{
    ptr[(words * WORD_BITS - bit - 1) / WORD_BITS] ^= 1UL << ((bit) % WORD_BITS);
}

__forceinline__ __device__  unsigned int countBitmapHammingDistance(unsigned long* first, unsigned long* second, unsigned int words)
{
    unsigned int count = 0;
    for (unsigned i = 0; i < words; ++i) {
        count += __popcll( *(first + i) ^ *(second + i) );
    }
    return count;
}

__global__ void generateBitmaps(DeviceCollection<unsigned int> collection)
{
    unsigned int globalID = blockIdx.x * blockDim.x + threadIdx.x;

    // iterate collection sets, each bitmap is generated by a unique thread
    for (int setID = globalID; setID < collection.numberOfSets; setID += blockDim.x * gridDim.x) {

        unsigned int setStart = collection.offsets[setID];
        unsigned int setEnd = setStart + collection.cardinalities[setID];

        for (unsigned int token = setStart; token < setEnd; ++token) {
            // hash function => h(t) = t % b, (t: token b: bitmapSize)
            change_bit(collection.bitmapAt(setID), collection.tokens[token] % collection.bitmapSize, collection.bitmapWords);
        }
    }
}

__global__ void bitmapFilter(Block probe, Block candidate, DeviceCollection<unsigned int> collection,
                                  DeviceArray<unsigned int> filter, unsigned int blockSize, double threshold) {
    unsigned int startID = (blockIdx.x * blockDim.x + threadIdx.x) + probe.startID;

    for (int probeID = startID; probeID <= probe.endID; probeID += blockDim.x * gridDim.x) {

        unsigned int probeSize = collection.cardinalities[probeID];
        unsigned int probeStart = collection.offsets[probeID];
        unsigned int probePrefix = probeStart + jaccard_maxprefix(probeSize, threshold);
        unsigned int normalizedProbeID = probeID - probe.id * blockSize;
        unsigned int maxsize = jaccard_maxsize(probeSize, threshold);
        word* probeBitmap = collection.bitmapAt(probeID);

        for (unsigned int candidateID = candidate.startID; candidateID <= candidate.endID; ++candidateID) {
            unsigned int candidateSize = collection.cardinalities[candidateID];

            if (probeID < candidateID && maxsize >= candidateSize) {
                unsigned int normalizedCandidateID = candidateID - candidate.id * blockSize;
                word *candidateBitmap = collection.bitmapAt(candidateID);

                unsigned int popcount = countBitmapHammingDistance(probeBitmap, candidateBitmap,
                                                                   collection.bitmapWords);
                unsigned int jaccardEqovelarp = jaccard_minoverlap(probeSize, candidateSize,
                                                                                threshold);
                double upperbound = (probeSize + candidateSize - popcount) / 2.0;

                unsigned int index = normalizedProbeID * blockSize + normalizedCandidateID;
                if (upperbound >= jaccardEqovelarp) {
                    filter[index] = 1;
                }
            }
        }
    }
}
#endif // BITMAP_GPUSSJOIN_BITMAP_HXX