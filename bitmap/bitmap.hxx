#ifndef BITMAP_GPUSSJOIN_BITMAP_HXX
#define BITMAP_GPUSSJOIN_BITMAP_HXX

#pragma once
#include "definitions.h"
#include "structs.hxx"
#include "similarity.hxx"

__forceinline__ __device__ uint32_t hash(uint32_t v)
{
    return v * UINT32_C(2654435761);
}

__forceinline__ __device__ void change_bit(word* ptr, uint32_t bit, unsigned int words)
{
    ptr[(words * WORD_BITS - bit - 1) / WORD_BITS] ^= 1UL << ((bit) % WORD_BITS);
}

__forceinline__ __device__  unsigned int countBitmapHammingDistance(unsigned long* first, unsigned long* second, unsigned int words)
{
    unsigned int count = 0;
    for (unsigned i = 0; i < words; ++i) {
        count += __popcll( *(first + i) ^ *(second + i) );
    }
    return count;
}

__global__ void generateBitmaps(DeviceCollection<unsigned int> collection)
{
    unsigned int globalID = blockIdx.x * blockDim.x + threadIdx.x;

    // iterate collection sets, each bitmap is generated by a unique thread
    for (int setID = globalID; setID < collection.numberOfSets; setID += blockDim.x * gridDim.x) {

        unsigned int setStart = collection.offsets[setID];
        unsigned int setEnd = setStart + collection.cardinalities[setID];

        for (unsigned int token = setStart; token < setEnd; ++token) {
            // hash function => h(t) = t % b, (t: token b: bitmapSize)
            change_bit(collection.bitmapAt(setID), collection.tokens[token] % collection.bitmapSize, collection.bitmapWords);
        }
    }
}

__global__ void bitmapFilter(Block leftBlock,
        Block rightBlock,
        DeviceCollection<unsigned int> input,
        DeviceCollection<unsigned int> foreign,
        DeviceArray<unsigned int> filter,
        unsigned int blockSize,
        double threshold){
    // starting right set
    unsigned int startID = (blockIdx.x * blockDim.x + threadIdx.x) + rightBlock.startID;

    // for every right set
    for (unsigned int rightID = startID; rightID <= rightBlock.endID; rightID += blockDim.x * gridDim.x) {

        unsigned int rightSetSize = foreign.cardinalities[rightID];

        unsigned int normalizedRightID = rightID - rightBlock.id * blockSize;
        unsigned int maxsize = jaccard_maxsize(rightSetSize, threshold);
        word* rightBitmap = foreign.bitmapAt(rightID);

        for (unsigned int leftID = leftBlock.startID; leftID <= leftBlock.endID; ++leftID) {
            unsigned int leftSetSize = input.cardinalities[leftID];

            if (rightID < leftID && maxsize >= leftSetSize) {
                unsigned int normalizedLeftID = leftID - leftBlock.id * blockSize;
                word* leftBitmap = input.bitmapAt(leftID);

                unsigned int popcount = countBitmapHammingDistance(rightBitmap, leftBitmap,
                                                                   input.bitmapWords);

                unsigned int jaccardEqovelarp = jaccard_minoverlap(rightSetSize, leftSetSize,
                                                                                threshold);
                double upperbound = (rightSetSize + leftSetSize - popcount) / 2.0;

                unsigned int index = normalizedRightID * blockSize + normalizedLeftID;
                if (upperbound >= jaccardEqovelarp) {
                    filter[index] = 1;
                }
            }
        }
    }
}
__global__ void binaryJoinBitmapFilter(Block leftBlock,
        Block rightBlock,
        DeviceCollection<unsigned int> input,
        DeviceCollection<unsigned int> foreign,
        DeviceArray<unsigned int> filter,
        unsigned int blockSize,
        double threshold) {
    unsigned int startID = (blockIdx.x * blockDim.x + threadIdx.x) + rightBlock.startID;
    for (unsigned int rightID = startID; rightID <= rightBlock.endID; rightID += blockDim.x * gridDim.x) {

        unsigned int rightSetSize = foreign.cardinalities[rightID];
        unsigned int normalizedRightID = rightID - rightBlock.id * blockSize;

        word* rightBitmap = foreign.bitmapAt(rightID);
        unsigned int maxsize = jaccard_maxsize(rightSetSize, threshold);

        for (unsigned int leftID = leftBlock.startID; leftID <= leftBlock.endID; ++leftID) {
            unsigned int leftSetSize = input.cardinalities[leftID];

            if (maxsize >= leftSetSize) {
                unsigned int normalizedLeftID = leftID - leftBlock.id * blockSize;
                word* leftBitmap = input.bitmapAt(leftID);

                unsigned int popcount = countBitmapHammingDistance(rightBitmap, leftBitmap,
                                                                   input.bitmapWords);

                unsigned int jaccardEqovelarp = jaccard_minoverlap(rightSetSize, leftSetSize,
                                                                   threshold);
                double upperbound = (rightSetSize + leftSetSize - popcount) / 2.0;

                unsigned int index = normalizedRightID * blockSize + normalizedLeftID;
                if (upperbound >= jaccardEqovelarp) {
                    filter[index] = 1;
                }
            }
        }
    }
}
#endif // BITMAP_GPUSSJOIN_BITMAP_HXX